<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DTechML Builder - Advanced</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    #editor {
      width: 100%;
      height: 150px;
      padding: 10px;
      font-family: monospace;
      border: 1px solid #ccc;
      margin-bottom: 10px;
    }
    #generate, #styleMode {
      padding: 10px 15px;
      margin-right: 10px;
      border: none;
      border-radius: 4px;
    }
    #generate { background: #007bff; color: white; }
    #styleMode { background: #28a745; color: white; }#layoutMode {
  padding: 5px;
  margin-left: 10px;
}

#preview-container {
  border: 2px dashed #ccc;
  overflow: auto;
  min-height: 300px;
  width: 100%;
  position: relative;
  margin-top: 15px;
}

#preview {
  position: relative;
  min-height: 100%;
  min-width: 100%;
}

.draggable {
  position: absolute;
  cursor: move;
  padding: 5px;
  touch-action: none;
}

#overlay, #stylePopup {
  position: fixed;
  z-index: 999;
}

#overlay {
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.4);
  display: none;
}

#stylePopup {
  top: 20%; left: 50%; transform: translateX(-50%);
  background: white; border: 1px solid #ccc;
  padding: 15px; display: none;
  box-shadow: 0 0 10px rgba(0,0,0,0.3);
}

#stylePopup input, #presetSelect {
  width: 100%;
  margin-bottom: 8px;
}

  </style>
</head>
<body>  <h1>DTechML Builder</h1>
  <textarea id="editor" placeholder="BTU=btn1,Download,https://youtube.com"></textarea><br />
  <button id="generate">Generate HTML</button>
  <button id="styleMode">Phase 2: Style Mode</button>
  <label>Layout Mode:</label>
  <select id="layoutMode">
    <option value="portrait">Portrait</option>
    <option value="landscape">Landscape</option>
    <option value="free">Free</option>
  </select>  <div id="preview-container">
    <div id="preview"></div>
  </div>  <!-- Style Popup -->  <div id="overlay"></div>
  <div id="stylePopup">
    <h3>Style Component</h3>
    <select id="presetSelect"></select>
    <input type="text" id="fontSize" placeholder="Font Size (e.g. 18px)" />
    <input type="text" id="color" placeholder="Text Color" />
    <input type="text" id="bgColor" placeholder="Background Color" />
    <input type="text" id="padding" placeholder="Padding" />
    <input type="text" id="borderRadius" placeholder="Border Radius" />
    <button onclick="applyStyles()">Apply</button>
    <button onclick="closePopup()">Close</button>
  </div>  <script>
    let commands = {};
    let cssPresets = {};
    let selectedElement = null;
    let styleMode = false;

    fetch('html_commands.json')
      .then(res => res.json())
      .then(data => commands = data);

    function parseLine(line) {
      const [cmd, rest] = line.split('=');
      if (!cmd || !rest) return { error: 'Invalid format' };
      const values = [];
      let current = '', inBraces = false;
      for (let i = 0; i < rest.length; i++) {
        const char = rest[i];
        if (char === '{') inBraces = true;
        else if (char === '}') inBraces = false;
        if (char === ',' && !inBraces) {
          values.push(current.trim()); current = '';
        } else current += char;
      }
      if (current) values.push(current.trim());
      return { cmd: cmd.trim(), values };
    }

    document.getElementById('generate').addEventListener('click', () => {
      const lines = document.getElementById('editor').value.trim().split('\n');
      const preview = document.getElementById('preview');
      preview.innerHTML = '';

      lines.forEach(line => {
        if (!line.trim()) return;
        const { cmd, values } = parseLine(line);
        const def = commands[cmd];
        if (!def) return;

        let html = def.template;
        def.required_fields.forEach((field, i) => {
          html = html.replace(`{${field}}`, values[i]?.replace(/[{}]/g, '') || '');
        });

        const wrapper = document.createElement('div');
        wrapper.className = 'draggable';
        wrapper.innerHTML = html;
        wrapper.style.left = '10px';
        wrapper.style.top = '10px';

        makeDraggable(wrapper);
        preview.appendChild(wrapper);
      });
    });

    document.getElementById('styleMode').addEventListener('click', () => {
      styleMode = true;
      fetch('CSS.json')
        .then(res => res.json())
        .then(data => cssPresets = data);
      alert('Style mode ON. Click a component to edit.');
    });

    document.getElementById('preview').addEventListener('click', e => {
      if (!styleMode || !e.target.closest('.draggable')) return;
      selectedElement = e.target.closest('.draggable').firstChild;
      const tag = selectedElement.tagName.toLowerCase();
      const cmd = Object.keys(commands).find(key => commands[key].template.includes(`<${tag}`));

      const presetSelect = document.getElementById('presetSelect');
      presetSelect.innerHTML = '<option value="">-- Select Preset --</option>';
      if (cssPresets[cmd]) {
        for (const name in cssPresets[cmd]) {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          presetSelect.appendChild(opt);
        }
      }

      presetSelect.onchange = () => {
        const preset = cssPresets[cmd][presetSelect.value];
        for (const [k, v] of Object.entries(preset)) selectedElement.style[k] = v;
      };

      document.getElementById('fontSize').value = selectedElement.style.fontSize || '';
      document.getElementById('color').value = selectedElement.style.color || '';
      document.getElementById('bgColor').value = selectedElement.style.backgroundColor || '';
      document.getElementById('padding').value = selectedElement.style.padding || '';
      document.getElementById('borderRadius').value = selectedElement.style.borderRadius || '';

      document.getElementById('overlay').style.display = 'block';
      document.getElementById('stylePopup').style.display = 'block';
    });

    function applyStyles() {
      if (!selectedElement) return;
      selectedElement.style.fontSize = document.getElementById('fontSize').value;
      selectedElement.style.color = document.getElementById('color').value;
      selectedElement.style.backgroundColor = document.getElementById('bgColor').value;
      selectedElement.style.padding = document.getElementById('padding').value;
      selectedElement.style.borderRadius = document.getElementById('borderRadius').value;
      closePopup();
    }

    function closePopup() {
      document.getElementById('overlay').style.display = 'none';
      document.getElementById('stylePopup').style.display = 'none';
    }

    function makeDraggable(el) {
      let offsetX = 0, offsetY = 0;
      const container = document.getElementById('preview-container');

      const getOffset = (x, y) => {
        const rect = container.getBoundingClientRect();
        return {
          x: x - rect.left + container.scrollLeft,
          y: y - rect.top + container.scrollTop
        };
      };

      const startDrag = (x, y) => {
        const elRect = el.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        offsetX = x - elRect.left + container.scrollLeft - containerRect.left;
        offsetY = y - elRect.top + container.scrollTop - containerRect.top;
      };

      const moveDrag = (x, y) => {
        const { x: relX, y: relY } = getOffset(x, y);
        el.style.left = (relX - offsetX) + 'px';
        el.style.top = (relY - offsetY) + 'px';
      };

      el.addEventListener('mousedown', (e) => {
        startDrag(e.pageX, e.pageY);
        const onMouseMove = (e) => moveDrag(e.pageX, e.pageY);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', () => {
          document.removeEventListener('mousemove', onMouseMove);
        }, { once: true });
      });

      el.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        startDrag(touch.pageX, touch.pageY);
        const onTouchMove = (e) => {
          const touch = e.touches[0];
          moveDrag(touch.pageX, touch.pageY);
        };
        document.addEventListener('touchmove', onTouchMove, { passive: false });
        document.addEventListener('touchend', () => {
          document.removeEventListener('touchmove', onTouchMove);
        }, { once: true });
      });
    }

    document.getElementById('layoutMode').addEventListener('change', function () {
      const mode = this.value;
      const container = document.getElementById('preview-container');
      const preview = document.getElementById('preview');
      if (mode === 'portrait') {
        container.style.overflowX = 'hidden';
        container.style.overflowY = 'auto';
        preview.style.display = 'block';
      } else if (mode === 'landscape') {
        container.style.overflowX = 'auto';
        container.style.overflowY = 'hidden';
        preview.style.display = 'flex';
        preview.style.flexDirection = 'row';
      } else {
        container.style.overflow = 'auto';
        preview.style.position = 'relative';
      }
    });
  </script></body>
</html>