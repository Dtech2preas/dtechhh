<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Webpage Snatcher Pro</title>
  <style>
    :root {
      --primary: #4361ee;
      --primary-dark: #3a56d4;
      --secondary: #3f37c9;
      --dark: #212529;
      --light: #f8f9fa;
      --success: #4cc9f0;
      --warning: #f8961e;
      --danger: #f72585;
      --gray: #6c757d;
      --gray-light: #e9ecef;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Segoe UI', 'Roboto', sans-serif;
      line-height: 1.6;
      background-color: #f5f7fa;
      color: var(--dark);
      padding: 2rem 1rem;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      overflow: hidden;
    }
    
    header {
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      color: white;
      padding: 1.5rem 2rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    header h1 {
      font-weight: 700;
      font-size: 1.8rem;
    }
    
    header .icon {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .main-content {
      padding: 2rem;
    }
    
    .input-group {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }
    
    input[type="text"] {
      flex: 1;
      padding: 0.8rem 1rem;
      border: 1px solid var(--gray-light);
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.2s;
    }
    
    input[type="text"]:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
    }
    
    button {
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .btn-primary {
      background-color: var(--primary);
      color: white;
    }
    
    .btn-primary:hover {
      background-color: var(--primary-dark);
    }
    
    .btn-success {
      background-color: var(--success);
      color: white;
    }
    
    .btn-success:hover {
      background-color: #3ab4d9;
    }
    
    button:disabled {
      background-color: var(--gray-light);
      color: var(--gray);
      cursor: not-allowed;
    }
    
    .options-panel {
      background: var(--gray-light);
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1.5rem;
    }
    
    .options-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1rem;
    }
    
    .option-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .progress-container {
      width: 100%;
      height: 8px;
      background: var(--gray-light);
      border-radius: 4px;
      margin: 1.5rem 0;
      overflow: hidden;
    }
    
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--success));
      width: 0%;
      transition: width 0.3s ease;
    }
    
    .log-container {
      background: #2b2d42;
      color: #f8f9fa;
      border-radius: 8px;
      padding: 1rem;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 0.9rem;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 1.5rem;
    }
    
    .log-entry {
      margin-bottom: 0.5rem;
      padding-left: 1.5rem;
      position: relative;
      line-height: 1.4;
    }
    
    .log-entry:before {
      content: ">";
      position: absolute;
      left: 0;
      color: var(--success);
    }
    
    .log-entry.info {
      color: #a7c6fa;
    }
    
    .log-entry.success {
      color: #4cc9f0;
    }
    
    .log-entry.warning {
      color: #f8961e;
    }
    
    .log-entry.error {
      color: #f72585;
    }
    
    .output-container {
      position: relative;
    }
    
    textarea {
      width: 100%;
      height: 400px;
      padding: 1rem;
      border: 1px solid var(--gray-light);
      border-radius: 8px;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 0.9rem;
      resize: vertical;
      background: #f8f9fa;
    }
    
    .copy-btn {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 0.3rem 0.6rem;
      font-size: 0.8rem;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
    }
    
    .output-container:hover .copy-btn {
      opacity: 1;
    }
    
    footer {
      text-align: center;
      margin-top: 2rem;
      color: var(--gray);
      font-size: 0.9rem;
    }
    
    @media (max-width: 768px) {
      .input-group {
        flex-direction: column;
      }
      
      button {
        width: 100%;
        justify-content: center;
      }
      
      .options-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="icon">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
          <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
          <line x1="12" y1="22.08" x2="12" y2="12"></line>
        </svg>
      </div>
      <h1>Webpage Snatcher Pro</h1>
    </header>
    
    <div class="main-content">
      <div class="input-group">
        <input type="text" id="urlInput" placeholder="Enter webpage URL (e.g. https://example.com or /local.html)">
        <button class="btn-primary" onclick="fetchPage()">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 12a9 9 0 0 1-9 9m9-9a9 9 0 0 0-9-9m9 9H3m9 9a9 9 0 0 1-9-9m9 9c1.66 0 3-4.03 3-9s-1.34-9-3-9m0 18c-1.66 0-3-4.03-3-9s1.34-9 3-9m-9 9a9 9 0 0 1 9-9"></path>
          </svg>
          Fetch
        </button>
      </div>
      
      <div class="options-panel">
        <h3>Processing Options</h3>
        <div class="options-grid">
          <div class="option-item">
            <input type="checkbox" id="inlineCSS" checked>
            <label for="inlineCSS">Inline CSS</label>
          </div>
          <div class="option-item">
            <input type="checkbox" id="inlineImages" checked>
            <label for="inlineImages">Inline Images</label>
          </div>
          <div class="option-item">
            <input type="checkbox" id="fixLinks" checked>
            <label for="fixLinks">Fix Relative Links</label>
          </div>
          <div class="option-item">
            <input type="checkbox" id="minifyHTML">
            <label for="minifyHTML">Minify HTML</label>
          </div>
        </div>
      </div>
      
      <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
      </div>
      
      <div class="log-container" id="logContainer">
        <div class="log-entry info">Ready to fetch webpage...</div>
      </div>
      
      <div class="output-container">
        <textarea id="output" placeholder="Processed HTML will appear here..." spellcheck="false"></textarea>
        <button class="copy-btn" onclick="copyToClipboard()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
          Copy
        </button>
      </div>
      
      <button class="btn-success" id="downloadBtn" disabled onclick="downloadHTML()">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
          <polyline points="7 10 12 15 17 10"></polyline>
          <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        Download HTML
      </button>
    </div>
  </div>
  
  <footer>
    Webpage Snatcher Pro &bull; Downloads complete webpages with all resources inlined
  </footer>

  <script>
    let processedHTML = '';
    const proxy = "https://api.allorigins.win/raw?url=";
    
    // Add log entry
    function addLog(message, type = 'info') {
      const logContainer = document.getElementById('logContainer');
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry ${type}`;
      logEntry.textContent = message;
      logContainer.appendChild(logEntry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }
    
    // Update progress bar
    function updateProgress(percent) {
      document.getElementById('progressBar').style.width = `${percent}%`;
    }
    
    // Show loading state
    function setLoading(isLoading) {
      const btn = document.querySelector('.btn-primary');
      btn.disabled = isLoading;
      if (isLoading) {
        btn.innerHTML = `
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 12a9 9 0 1 1-6.219-8.56" />
          </svg>
          Fetching...
        `;
      } else {
        btn.innerHTML = `
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 12a9 9 0 0 1-9 9m9-9a9 9 0 0 0-9-9m9 9H3m9 9a9 9 0 0 1-9-9m9 9c1.66 0 3-4.03 3-9s-1.34-9-3-9m0 18c-1.66 0-3-4.03-3-9s1.34-9 3-9m-9 9a9 9 0 0 1 9-9"></path>
          </svg>
          Fetch
        `;
      }
    }
    
    // Fetch content with error handling
    async function fetchContent(url) {
      try {
        // Try direct fetch first (works for local files if CORS allows)
        addLog(`Fetching: ${url}`, 'info');
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.text();
      } catch (e) {
        // Fall back to proxy for remote URLs if direct fetch fails
        if (!url.startsWith('http')) {
          throw new Error('Local file access blocked by CORS. Try running this tool locally.');
        }
        addLog(`Using proxy for: ${url}`, 'warning');
        const proxyUrl = proxy + encodeURIComponent(url);
        const response = await fetch(proxyUrl);
        return await response.text();
      }
    }
    
    // Process CSS resources
    async function processCSS(doc, basePath) {
      const stylesheets = Array.from(doc.querySelectorAll('link[rel="stylesheet"]'));
      if (stylesheets.length === 0) {
        addLog('No external CSS found', 'info');
        return;
      }
      
      addLog(`Processing ${stylesheets.length} CSS files...`, 'info');
      updateProgress(10);
      
      for (const [index, link] of stylesheets.entries()) {
        const href = link.getAttribute('href');
        if (!href) continue;
        
        try {
          const cssUrl = href.startsWith('http') ? href : basePath + href;
          addLog(`[${index+1}/${stylesheets.length}] Loading CSS: ${cssUrl}`, 'info');
          
          const cssContent = await fetchContent(cssUrl);
          
          // Create style tag with the CSS content
          const style = document.createElement('style');
          style.textContent = `/* Inlined from ${cssUrl} */\n${cssContent}`;
          link.replaceWith(style);
          
          addLog(`[${index+1}/${stylesheets.length}] CSS inlined successfully`, 'success');
          updateProgress(10 + ((index + 1) / stylesheets.length * 40));
        } catch (e) {
          addLog(`Failed to load CSS: ${href} - ${e.message}`, 'error');
          link.remove();
        }
      }
    }
    
    // Process image resources
    async function processImages(doc, basePath) {
      const images = Array.from(doc.querySelectorAll('img'));
      if (images.length === 0) {
        addLog('No images found', 'info');
        return;
      }
      
      addLog(`Processing ${images.length} images...`, 'info');
      updateProgress(50);
      
      for (const [index, img] of images.entries()) {
        const src = img.getAttribute('src');
        if (!src) continue;
        
        try {
          const imgUrl = src.startsWith('http') ? src : basePath + src;
          addLog(`[${index+1}/${images.length}] Loading image: ${imgUrl}`, 'info');
          
          const response = await fetch(imgUrl);
          const blob = await response.blob();
          
          // Convert to base64 data URL
          const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(blob);
          });
          
          img.src = dataUrl;
          
          addLog(`[${index+1}/${images.length}] Image converted to base64`, 'success');
          updateProgress(50 + ((index + 1) / images.length * 40));
        } catch (e) {
          addLog(`Failed to load image: ${src} - ${e.message}`, 'error');
        }
      }
    }
    
    // Fix relative links
    function fixRelativeLinks(doc, basePath) {
      const elements = doc.querySelectorAll('[href],[src]');
      let fixedCount = 0;
      
      elements.forEach(el => {
        const attr = el.hasAttribute('href') ? 'href' : 'src';
        const value = el.getAttribute(attr);
        
        if (value && !value.startsWith('http') && !value.startsWith('data:') && !value.startsWith('#')) {
          el.setAttribute(attr, basePath + value);
          fixedCount++;
        }
      });
      
      addLog(`Fixed ${fixedCount} relative paths`, 'success');
    }
    
    // Minify HTML
    function minifyHTML(html) {
      addLog('Minifying HTML...', 'info');
      return html
        .replace(/<!--.*?-->/gs, '')
        .replace(/\s+/g, ' ')
        .replace(/>\s+</g, '><')
        .trim();
    }
    
    // Build final HTML document
    function buildFinalHTML(doc) {
      addLog('Building final HTML structure...', 'info');
      
      // Ensure proper HTML structure
      const html = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${doc.title || 'Downloaded Page'}</title>
  ${getHeadContent(doc)}
</head>
<body>
  ${getBodyContent(doc)}
</body>
</html>`;
      
      return html;
    }
    
    function getHeadContent(doc) {
      const head = doc.head;
      let content = '';
      
      // Copy all elements except title and viewport (we handle those separately)
      for (const child of head.children) {
        if (child.tagName !== 'TITLE' && child.getAttribute('name') !== 'viewport') {
          content += child.outerHTML + '\n';
        }
      }
      
      return content;
    }
    
    function getBodyContent(doc) {
      return doc.body.innerHTML;
    }
    
    // Main function to fetch and process page
    async function fetchPage() {
      const url = document.getElementById('urlInput').value.trim();
      if (!url) {
        addLog('Please enter a URL', 'error');
        return;
      }
      
      try {
        // Reset UI
        setLoading(true);
        document.getElementById('output').value = '';
        document.getElementById('downloadBtn').disabled = true;
        document.getElementById('logContainer').innerHTML = '';
        updateProgress(0);
        addLog(`Starting fetch for: ${url}`, 'info');
        
        // Get the HTML content
        const html = await fetchContent(url);
        addLog('HTML content received, processing...', 'success');
        
        // Parse the HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Get base path for relative URLs
        const basePath = getBasePath(url);
        addLog(`Using base path: ${basePath}`, 'info');
        
        // Process options
        const shouldInlineCSS = document.getElementById('inlineCSS').checked;
        const shouldInlineImages = document.getElementById('inlineImages').checked;
        const shouldFixLinks = document.getElementById('fixLinks').checked;
        const shouldMinify = document.getElementById('minifyHTML').checked;
        
        // Process resources
        if (shouldInlineCSS) await processCSS(doc, basePath);
        if (shouldInlineImages) await processImages(doc, basePath);
        if (shouldFixLinks) fixRelativeLinks(doc, basePath);
        
        // Build final HTML
        let finalHTML = buildFinalHTML(doc);
        if (shouldMinify) finalHTML = minifyHTML(finalHTML);
        
        // Update UI with results
        processedHTML = finalHTML;
        document.getElementById('output').value = finalHTML;
        document.getElementById('downloadBtn').disabled = false;
        updateProgress(100);
        addLog('Page processed successfully! Ready to download.', 'success');
      } catch (err) {
        addLog(`Error: ${err.message}`, 'error');
        console.error(err);
      } finally {
        setLoading(false);
      }
    }
    
    // Download HTML file
    function downloadHTML() {
      if (!processedHTML) return;
      
      const blob = new Blob([processedHTML], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      
      const filename = getDownloadFilename();
      addLog(`Downloading: ${filename}`, 'info');
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      addLog('Download complete!', 'success');
    }
    
    // Generate download filename
    function getDownloadFilename() {
      const url = document.getElementById('urlInput').value.trim();
      if (!url) return 'downloaded_page.html';
      
      if (url.startsWith('http')) {
        const domain = new URL(url).hostname.replace('www.', '');
        const path = new URL(url).pathname.split('/').pop();
        return path ? `${domain}_${path}` : `${domain}.html`;
      }
      
      // For local paths
      const filename = url.split('/').pop();
      return filename.endsWith('.html') ? filename : `${filename}.html`;
    }
    
    // Copy to clipboard
    function copyToClipboard() {
      const output = document.getElementById('output');
      output.select();
      document.execCommand('copy');
      
      // Show temporary feedback
      const copyBtn = document.querySelector('.copy-btn');
      copyBtn.innerHTML = `
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
        Copied!
      `;
      
      setTimeout(() => {
        copyBtn.innerHTML = `
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
          Copy
        `;
      }, 2000);
      
      addLog('HTML copied to clipboard', 'success');
    }
    
    // Helper function to get base path
    function getBasePath(url) {
      if (url.startsWith('http')) {
        const urlObj = new URL(url);
        return `${urlObj.protocol}//${urlObj.host}${urlObj.pathname.split('/').slice(0, -1).join('/')}/`;
      }
      // For local paths, get directory path
      const lastSlash = url.lastIndexOf('/');
      return lastSlash > 0 ? url.substring(0, lastSlash + 1) : './';
    }
  </script>
</body>
</html>