<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Beauty Showcase — Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <meta name="theme-color" content="#000000">
  <style>
    :root {
      --bg: #000;
      --overlay-gradient: linear-gradient(180deg, rgba(0,0,0,.85) 0%, rgba(0,0,0,0) 60%);
      --footer-gradient: linear-gradient(0deg, rgba(0,0,0,.85) 0%, rgba(0,0,0,0) 60%);
      --transition: .25s ease;
      --like-color: rgba(255,64,129,0.95);
      --like-hover: rgba(255,64,129,1);
      --action-btn-size: 48px;
      --action-btn-gap: 16px;
      --limit-overlay: rgba(0,0,0,0.9);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
      touch-action: pan-y;
    }
    
    /* Settings Button */
    .identity-button {
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(255,255,255,.15);
      border: 2px solid rgba(255,255,255,.5);
      padding: 10px 12px;
      border-radius: 12px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: flex-start;
      width: 48px;
      height: 40px;
      justify-content: center;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0,0,0,.3);
      transition: all var(--transition);
      backdrop-filter: blur(8px);
    }
    
    .identity-button:hover {
      background: rgba(255,255,255,.25);
      transform: scale(1.05);
    }
    
    .identity-button span {
      display: block;
      width: 24px;
      height: 3px;
      background: #fff;
      border-radius: 3px;
      transition: all var(--transition);
    }
    
    .identity-button:hover span {
      background: rgba(255,255,255,.9);
    }
    
    /* Main Viewer Container */
    .viewer-container {
      height: 100vh;
      overflow-y: scroll;
      scroll-snap-type: y mandatory;
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
    }
    
    /* Profile Slides */
    .profile-slide {
      position: relative;
      height: 100vh;
      scroll-snap-align: start;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
    }
    
    .profile-slide img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      user-select: none;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }
    
    /* Profile Info Overlay */
    .overlay-top {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 24px 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      background: var(--overlay-gradient);
      z-index: 5;
      transition: all var(--transition);
    }
    
    .profile-info {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-width: 75%;
    }
    
    .profile-info .username {
      font-size: 1.8rem;
      font-weight: 700;
      line-height: 1.1;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    .profile-info .sub {
      font-size: 1rem;
      opacity: 0.9;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    
    .like-area {
      margin-top: 12px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .like-btn {
      background: var(--like-color);
      border: none;
      padding: 12px 20px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #fff;
      font-weight: 600;
      backdrop-filter: blur(4px);
      transition: all var(--transition);
      box-shadow: 0 4px 15px rgba(255,64,129,0.3);
    }
    
    .like-btn:hover:not(:disabled) {
      background: var(--like-hover);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255,64,129,0.4);
    }
    
    .like-btn:disabled {
      opacity: 0.7;
      cursor: not-allowed;
    }
    
    .like-btn:active:not(:disabled) {
      transform: translateY(0);
    }
    
    .likes-count {
      margin-left: 4px;
      font-weight: 700;
    }
    
    /* Footer */
    .viewer-footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--footer-gradient);
      z-index: 5;
      gap: 12px;
      flex-wrap: wrap;
      backdrop-filter: blur(8px);
    }
    
    .user-status {
      font-size: 0.95rem;
      opacity: 0.9;
    }
    
    .limit-warning {
      color: #ff9e9e;
      font-weight: 600;
    }
    
    /* Loading Indicator */
    .loader {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,.8);
      padding: 16px 24px;
      border-radius: 12px;
      font-size: 16px;
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .loader:before {
      content: "";
      display: block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,0.2);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Floating Action Buttons */
    .floating-actions {
      position: fixed;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: var(--action-btn-gap);
      z-index: 50;
    }
    
    .action-btn {
      background: rgba(255,255,255,.1);
      border: none;
      padding: 12px;
      border-radius: 50%;
      cursor: pointer;
      width: var(--action-btn-size);
      height: var(--action-btn-size);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 25px rgba(0,0,0,0.3);
      transition: all var(--transition);
    }
    
    .action-btn:hover {
      background: rgba(255,255,255,.2);
      transform: scale(1.1);
    }
    
    .action-btn:active {
      transform: scale(0.95);
    }
    
    .action-btn svg {
      width: 22px;
      height: 22px;
      fill: #fff;
    }
    
    .tooltip {
      position: absolute;
      right: calc(100% + 12px);
      top: 50%;
      transform: translateY(-50%);
      background: rgba(0,0,0,.9);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity .2s ease;
      z-index: 12;
    }
    
    .action-btn:hover .tooltip {
      opacity: 1;
    }
    
    /* Empty State */
    .empty-state {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #fff;
      width: 80%;
      max-width: 400px;
    }
    
    .empty-state h3 {
      font-size: 1.5rem;
      margin-bottom: 12px;
    }
    
    .empty-state p {
      opacity: 0.8;
      line-height: 1.5;
    }
    
    /* Limit Overlay */
    .limit-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--limit-overlay);
      z-index: 200;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      text-align: center;
    }
    
    .limit-message {
      font-size: 1.2rem;
      margin-bottom: 20px;
      max-width: 400px;
      line-height: 1.5;
    }
    
    .limit-btn {
      background: var(--like-color);
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition);
    }
    
    .limit-btn:hover {
      background: var(--like-hover);
      transform: translateY(-2px);
    }
    
    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .fade-in {
      animation: fadeIn 0.5s ease forwards;
    }
    
    /* Responsive Adjustments */
    @media (max-width: 600px) {
      .profile-info .username {
        font-size: 1.5rem;
      }
      
      .profile-info .sub {
        font-size: 0.9rem;
      }
      
      .like-btn {
        padding: 10px 16px;
        font-size: 15px;
      }
      
      .floating-actions {
        right: 12px;
        gap: 12px;
      }
      
      .action-btn {
        width: 44px;
        height: 44px;
      }
      
      .action-btn svg {
        width: 20px;
        height: 20px;
      }
      
      .limit-message {
        font-size: 1rem;
      }
    }
    
    @media (max-width: 400px) {
      .profile-info {
        max-width: 85%;
      }
      
      .overlay-top {
        padding: 20px 16px;
      }
      
      .viewer-footer {
        padding: 16px;
      }
    }
  </style>
</head>
<body>
  <!-- Settings Button -->
  <button class="identity-button" aria-label="Settings" onclick="location.href='settings.html'">
    <span></span><span></span><span></span>
  </button>

  <!-- Floating Action Buttons -->
  <div class="floating-actions">
    <button class="action-btn" id="shareBtn" aria-label="Copy profile link">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M13 5.828V2h-2v3.828a3 3 0 0 0-1.586.52L7.05 5.05l-1.414 1.414 2.364 2.364A3 3 0 0 0 8 11a3 3 0 0 0 .586-.05l2.364 2.364 1.414-1.414-2.364-2.364A3 3 0 0 0 13 8a3 3 0 0 0 .05-.586l2.364-2.364L14.05 5.05 12.414 6.686A3 3 0 0 0 13 5.828z"></path>
      </svg>
      <div class="tooltip">Copy profile link</div>
    </button>
    <button class="action-btn" id="viewProfileBtn" aria-label="View profile">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M12 12a5 5 0 1 0 0-10 5 5 0 0 0 0 10zm0 2c-3.866 0-7 1.79-7 4v2h14v-2c0-2.21-3.134-4-7-4z"/>
      </svg>
      <div class="tooltip">Open profile</div>
    </button>
  </div>

  <!-- Main Viewer Container -->
  <div class="viewer-container" id="viewerContainer"></div>

  <!-- Footer -->
  <div class="viewer-footer">
    <div class="user-status" id="identityDisplay">Loading identity...</div>
    <div class="user-status" id="likeStatus">Likes today: --</div>
    <div class="user-status" id="scrollStatus">Scrolls today: --</div>
  </div>

  <!-- Loader -->
  <div class="loader" id="globalStatus" style="display:none;">Loading...</div>

  <!-- Limit Overlay -->
  <div class="limit-overlay" id="limitOverlay" style="display:none;">
    <div class="limit-message" id="limitMessage"></div>
    <button class="limit-btn" id="limitBtn">Review Access</button>
  </div>

  <script>
    // CONFIG
    const GIST_TOKEN_URL = "https://gist.githubusercontent.com/Dtech2preas/6750d0418aaa9dfe7f297c26d1dfae48/raw/2e511e4d11267d5aade0229849446b7297ae01c9/gistfile1.txt";
    const REPO_OWNER = "Dtech2preas", REPO_NAME = "Oratilr", DATA_FILE_PATH = "data1.json";
    const TOKEN_TTL = 30000;
    const MAX_LIKES_PER_DAY = 10;
    const MAX_SCROLLS_PER_DAY = 30;

    // STATE
    let identity = null;
    let cachedToken = null, tokenFetchedAt = 0;
    let profiles = [];
    let currentIndex = 0;
    let isUpdating = false;
    let viewedProfiles = [];
    let requestedProfile = null;
    let scrollCount = 0;
    let lastScrollTime = 0;
    let scrollDebounce = null;

    // DOM
    const viewerContainer = document.getElementById("viewerContainer");
    const identityDisplay = document.getElementById("identityDisplay");
    const likeStatus = document.getElementById("likeStatus");
    const scrollStatus = document.getElementById("scrollStatus");
    const globalStatus = document.getElementById("globalStatus");
    const shareBtn = document.getElementById("shareBtn");
    const viewProfileBtn = document.getElementById("viewProfileBtn");
    const limitOverlay = document.getElementById("limitOverlay");
    const limitMessage = document.getElementById("limitMessage");
    const limitBtn = document.getElementById("limitBtn");

    // Utility Functions
    function showStatus(msg) {
      globalStatus.textContent = msg;
      globalStatus.style.display = "flex";
    }
    
    function hideStatus() {
      globalStatus.style.display = "none";
    }
    
    function escapeHTML(s) { 
      if (!s) return ""; 
      return s.replace(/[&<>"']/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"}[c])); 
    }

    function showLimitOverlay(message) {
      limitMessage.textContent = message;
      limitOverlay.style.display = "flex";
    }

    function hideLimitOverlay() {
      limitOverlay.style.display = "none";
    }

    // Check URL for requested profile
    function checkUrlForProfile() {
      const params = new URLSearchParams(window.location.search);
      const userParam = params.get('user');
      if (userParam) {
        requestedProfile = userParam.toLowerCase();
      }
    }

    // Get weighted random profile index (more likes = higher chance)
    function getWeightedRandomProfileIndex() {
      if (profiles.length === 0) return -1;
      
      // If we have a requested profile, find it first
      if (requestedProfile) {
        const index = profiles.findIndex(p => 
          String(p.username).toLowerCase() === requestedProfile
        );
        if (index !== -1) {
          requestedProfile = null; // Clear after first use
          return index;
        }
      }
      
      // If we've viewed all profiles, reset the viewed list
      if (viewedProfiles.length >= profiles.length) {
        viewedProfiles = [];
      }
      
      // Create a pool of unviewed profiles
      const unviewedProfiles = profiles
        .map((p, i) => ({ index: i, profile: p }))
        .filter(p => !viewedProfiles.includes(p.index));
      
      // If all profiles have been viewed, use all profiles
      const pool = unviewedProfiles.length > 0 ? unviewedProfiles : 
        profiles.map((p, i) => ({ index: i, profile: p }));
      
      // Calculate total weight (sum of all likes + 1 to avoid zero)
      const totalWeight = pool.reduce((sum, p) => sum + (p.profile.likes || 0) + 1, 0);
      
      // Get a random number in the weight range
      let random = Math.random() * totalWeight;
      let weightSum = 0;
      
      for (const p of pool) {
        weightSum += (p.profile.likes || 0) + 1;
        if (random <= weightSum) {
          viewedProfiles.push(p.index);
          return p.index;
        }
      }
      
      // Fallback to first profile if something went wrong
      return 0;
    }

    // Scroll to specific profile
    function scrollToProfile(index) {
      const slides = document.querySelectorAll('.profile-slide');
      if (index >= 0 && index < slides.length) {
        slides[index].scrollIntoView({ behavior: 'smooth' });
        currentIndex = index;
      }
    }

    // Check daily limits
    function checkDailyLimits() {
      const today = new Date().toISOString().slice(0, 10);
      
      // Reset counts if it's a new day
      if (identity.lastActivityDate !== today) {
        identity.likesToday = 0;
        identity.scrollsToday = 0;
        identity.lastActivityDate = today;
        localStorage.setItem("beauty_identity", JSON.stringify(identity));
      }
      
      // Check if limits are exceeded
      if (identity.likesToday >= MAX_LIKES_PER_DAY) {
        showLimitOverlay(`You've reached your daily limit of ${MAX_LIKES_PER_DAY} likes. Please review your access to continue.`);
        return false;
      }
      
      if (identity.scrollsToday >= MAX_SCROLLS_PER_DAY) {
        showLimitOverlay(`You've reached your daily limit of ${MAX_SCROLLS_PER_DAY} scrolls. Please review your access to continue.`);
        return false;
      }
      
      hideLimitOverlay();
      return true;
    }

    // Identity Management
    function loadIdentity() {
      try {
        const stored = JSON.parse(localStorage.getItem("beauty_identity") || "null");
        if (!stored || !stored.username) throw new Error("no identity");
        
        const today = new Date().toISOString().slice(0, 10);
        if (stored.lastActivityDate !== today) {
          stored.likesToday = 0;
          stored.scrollsToday = 0;
          stored.lastActivityDate = today;
        }
        
        identity = stored;
        localStorage.setItem("beauty_identity", JSON.stringify(identity));
        refreshIdentityUI();
        checkDailyLimits();
      } catch {
        location.href = "auth.html";
      }
    }

    function refreshIdentityUI() {
      if (!identity) return;
      
      identityDisplay.innerHTML = identity.anonymous
        ? `Anonymous: <strong>${escapeHTML(identity.username)}</strong>`
        : `Logged in: <strong>${escapeHTML(identity.username)}</strong>`;
      
      likeStatus.innerHTML = `Likes today: <strong>${identity.likesToday || 0}/${MAX_LIKES_PER_DAY}</strong>`;
      scrollStatus.innerHTML = `Scrolls today: <strong>${identity.scrollsToday || 0}/${MAX_SCROLLS_PER_DAY}</strong>`;
      
      if (identity.likesToday >= MAX_LIKES_PER_DAY) {
        likeStatus.classList.add("limit-warning");
      } else {
        likeStatus.classList.remove("limit-warning");
      }
      
      if (identity.scrollsToday >= MAX_SCROLLS_PER_DAY) {
        scrollStatus.classList.add("limit-warning");
      } else {
        scrollStatus.classList.remove("limit-warning");
      }
    }

    function canLike() {
      if (!identity) return false;
      return identity.likesToday < MAX_LIKES_PER_DAY;
    }

    function canScroll() {
      if (!identity) return false;
      return identity.scrollsToday < MAX_SCROLLS_PER_DAY;
    }

    function recordLike() {
      const today = new Date().toISOString().slice(0, 10);
      if (!identity) return;
      
      if (identity.lastActivityDate !== today) {
        identity.likesToday = 0;
        identity.scrollsToday = 0;
        identity.lastActivityDate = today;
      }
      
      identity.likesToday = (identity.likesToday || 0) + 1;
      localStorage.setItem("beauty_identity", JSON.stringify(identity));
      refreshIdentityUI();
      checkDailyLimits();
    }

    function recordScroll() {
      const now = Date.now();
      // Debounce rapid scroll events (minimum 500ms between recorded scrolls)
      if (now - lastScrollTime < 500) return;
      
      lastScrollTime = now;
      const today = new Date().toISOString().slice(0, 10);
      if (!identity) return;
      
      if (identity.lastActivityDate !== today) {
        identity.likesToday = 0;
        identity.scrollsToday = 0;
        identity.lastActivityDate = today;
      }
      
      identity.scrollsToday = (identity.scrollsToday || 0) + 1;
      localStorage.setItem("beauty_identity", JSON.stringify(identity));
      refreshIdentityUI();
      
      // Check if scroll limit is reached
      if (identity.scrollsToday >= MAX_SCROLLS_PER_DAY) {
        showLimitOverlay(`You've reached your daily limit of ${MAX_SCROLLS_PER_DAY} scrolls. Please review your access to continue.`);
      }
    }

    // API Functions
    async function timeoutFetch(url, opts = {}, ms = 8000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), ms);
      try { 
        return await fetch(url, {...opts, signal: controller.signal}); 
      } finally { 
        clearTimeout(id); 
      }
    }

    async function fetchToken() {
      if (cachedToken && (Date.now() - tokenFetchedAt) < TOKEN_TTL) return cachedToken;
      const res = await timeoutFetch(GIST_TOKEN_URL);
      if (!res || !res.ok) throw new Error("token fetch failed");
      const t = (await res.text()).trim();
      if (!t) throw new Error("empty token");
      cachedToken = t;
      tokenFetchedAt = Date.now();
      return t;
    }

    async function getRepoFile(token) {
      const url = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${DATA_FILE_PATH}`;
      const res = await timeoutFetch(url, {
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: "application/vnd.github.v3+json"
        }
      });
      if (!res.ok) throw new Error("failed to fetch contents");
      return await res.json();
    }

    async function updateRepoFile(token, sha, arr) {
      const url = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${DATA_FILE_PATH}`;
      const body = {
        message: "Update profile",
        content: btoa(unescape(encodeURIComponent(JSON.stringify(arr, null, 2)))),
        sha
      };
      const res = await timeoutFetch(url, {
        method: "PUT",
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: "application/vnd.github.v3+json",
          "Content-Type": "application/json"
        },
        body: JSON.stringify(body)
      }, 10000);
      if (!res.ok) {
        const txt = await res.text();
        throw new Error("update failed: " + txt);
      }
      return await res.json();
    }

    // Profile Loading and Display
    async function loadProfiles() {
      showStatus("Loading gallery...");
      try {
        const token = await fetchToken();
        const fileInfo = await getRepoFile(token);
        let arr = [];
        try { arr = JSON.parse(atob(fileInfo.content)); } catch {}
        if (!Array.isArray(arr)) arr = [];
        profiles = arr;
        hideStatus();
        renderSlides();
      } catch (e) {
        showStatus("Failed to load profiles: " + e.message);
        setTimeout(() => {
          showStatus("Retrying...");
          loadProfiles();
        }, 3000);
      }
    }

    function renderSlides() {
      viewerContainer.innerHTML = "";
      if (!profiles.length) {
        viewerContainer.innerHTML = `
          <div class="profile-slide">
            <div class="empty-state fade-in">
              <h3>No profiles yet</h3>
              <p>Check back later or be the first to contribute to the showcase</p>
            </div>
          </div>
        `;
        return;
      }
      
      // Sort by likes (highest first) for initial display
      profiles.sort((a, b) => (b.likes || 0) - (a.likes || 0));
      
      // Create slides for all profiles
      profiles.forEach((p, idx) => {
        const slide = document.createElement("div");
        slide.className = "profile-slide fade-in";
        slide.dataset.index = idx;
        
        // Format the timestamp nicely
        const uploadDate = new Date(p.timestamp || 0);
        const formattedDate = uploadDate.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        });
        
        slide.innerHTML = `
          <img src="${escapeHTML(p.image)}" loading="lazy" alt="${escapeHTML(p.username || 'profile')}" />
          <div class="overlay-top">
            <div class="profile-info">
              <div class="username">${escapeHTML(p.username || "")}</div>
              <div class="sub">
                ${p.fullName ? escapeHTML(p.fullName) + " • " : ""}
                Age: ${escapeHTML(String(p.age || ""))} • 
                Uploaded: ${formattedDate}
              </div>
              <div class="like-area">
                <button class="like-btn" data-username="${escapeHTML(p.username)}">
                  ❤️ <span class="likes-count">${p.likes || 0}</span>
                </button>
              </div>
            </div>
          </div>
        `;
        viewerContainer.appendChild(slide);
      });
      
      attachLikeHandlers();
      trackScroll();
      
      // Scroll to a weighted random profile or the requested one
      setTimeout(() => {
        const index = getWeightedRandomProfileIndex();
        if (index !== -1) {
          scrollToProfile(index);
        }
      }, 100);
    }

    function attachLikeHandlers() {
      document.querySelectorAll(".like-btn").forEach(btn => {
        btn.onclick = async (e) => {
          e.stopPropagation();
          
          // Check daily limits
          if (!checkDailyLimits()) return;
          
          const target = btn.dataset.username;
          
          if (!identity) {
            alert("Please login to like profiles.");
            return;
          }
          
          if (!canLike()) {
            showLimitOverlay(`You've reached your daily limit of ${MAX_LIKES_PER_DAY} likes. Please review your access to continue.`);
            return;
          }
          
          if (isUpdating) return;
          
          isUpdating = true;
          btn.disabled = true;
          showStatus("Sending like...");
          
          try {
            await incrementLike(target);
            recordLike();
            
            // Update UI count with animation
            const span = btn.querySelector(".likes-count");
            if (span) {
              span.style.transform = "scale(1.2)";
              setTimeout(() => {
                span.style.transform = "scale(1)";
              }, 200);
              
              const updated = profiles.find(p => 
                String(p.username).toLowerCase() === String(target).toLowerCase()
              );
              span.textContent = updated?.likes || "0";
            }
            
            hideStatus();
          } catch (err) {
            showStatus("Like failed: " + err.message);
            setTimeout(hideStatus, 2000);
          } finally {
            btn.disabled = false;
            isUpdating = false;
          }
        };
      });
    }

    async function incrementLike(username, maxRetries = 3) {
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        const token = await fetchToken();
        const fileInfo = await getRepoFile(token);
        let arr = [];
        try { arr = JSON.parse(atob(fileInfo.content)); } catch {}
        
        const idx = arr.findIndex(x => 
          String(x.username).toLowerCase() === String(username).toLowerCase()
        );
        
        if (idx === -1) throw new Error("Profile not found");
        
        arr[idx].likes = (arr[idx].likes || 0) + 1;
        
        try {
          await updateRepoFile(token, fileInfo.sha, arr);
          profiles = arr; // refresh local
          return arr[idx].likes;
        } catch (e) {
          if ((e.message.includes("409") || e.code === 409) && attempt < maxRetries) {
            await new Promise(r => setTimeout(r, 100 * attempt));
            continue;
          }
          throw e;
        }
      }
      throw new Error("Failed to increment like");
    }

    // Scroll Tracking
    function trackScroll() {
      let isScrolling;
      
      viewerContainer.addEventListener("scroll", () => {
        // Clear our timeout throughout the scroll
        window.clearTimeout(isScrolling);
        
        // Set a timeout to run after scrolling ends
        isScrolling = setTimeout(() => {
          if (!canScroll()) return;
          
          const slides = [...document.querySelectorAll(".profile-slide")];
          const viewportHeight = window.innerHeight;
          const mid = viewportHeight / 2;
          let nearest = currentIndex;
          let minDist = Infinity;
          
          slides.forEach(s => {
            const rect = s.getBoundingClientRect();
            const center = rect.top + rect.height / 2;
            const d = Math.abs(center - mid);
            
            if (d < minDist) {
              minDist = d;
              nearest = Number(s.dataset.index);
            }
          });
          
          // Only record scroll if we actually changed profiles
          if (nearest !== currentIndex) {
            currentIndex = nearest;
            recordScroll();
            
            // Update URL without reloading
            const currentProfile = profiles[nearest];
            if (currentProfile) {
              const newUrl = `${window.location.pathname}?user=${encodeURIComponent(currentProfile.username)}`;
              window.history.replaceState(null, null, newUrl);
            }
          }
        }, 100);
      });
    }

    // Current Profile Utilities
    function currentProfile() {
      if (!profiles || profiles.length === 0) return null;
      return profiles[currentIndex] || profiles[0];
    }

    // Button Event Handlers
    shareBtn.addEventListener("click", () => {
      const p = currentProfile();
      if (!p) return;
      
      const url = `${window.location.origin}${window.location.pathname}?user=${encodeURIComponent(p.username)}`;
      
      navigator.clipboard.writeText(url).then(() => {
        showStatus("Link copied!");
        setTimeout(hideStatus, 1500);
      }).catch(() => {
        prompt("Copy this link:", url);
      });
    });

    viewProfileBtn.addEventListener("click", () => {
      const p = currentProfile();
      if (!p) return;
      location.href = `profile.html?user=${encodeURIComponent(p.username)}`;
    });

    limitBtn.addEventListener("click", () => {
      location.href = "redo.html";
    });

    // Initialization
    async function init() {
      checkUrlForProfile();
      loadIdentity();
      await loadProfiles();
      
      // Add subtle parallax effect to images
      document.querySelectorAll('.profile-slide img').forEach(img => {
        img.parentElement.addEventListener('mousemove', (e) => {
          if (window.innerWidth > 768) { // Only on desktop
            const x = e.clientX / window.innerWidth;
            const y = e.clientY / window.innerHeight;
            img.style.transform = `translate(${x * 10}px, ${y * 10}px)`;
          }
        });
        
        img.parentElement.addEventListener('mouseleave', () => {
          img.style.transform = 'translate(0, 0)';
        });
      });
    }

    // Start the app
    init();
  </script>
</body>
</html>