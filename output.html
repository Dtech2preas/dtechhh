<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Tool to copy a webpage and inline all CSS and images">
  <title>Mini HTTrack - Webpage Copier with Full CSS Inlining</title>
  <style>
    :root {
      --primary-color: #2563eb;
      --secondary-color: #1e40af;
      --text-color: #1f2937;
      --bg-color: #f9fafb;
      --border-color: #e5e7eb;
      --error-color: #dc2626;
      --success-color: #16a34a;
    }
    
    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      line-height: 1.6;
      color: var(--text-color);
      background-color: var(--bg-color);
      padding: 2rem;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    h1 {
      color: var(--primary-color);
      margin-bottom: 1.5rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .input-group {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }
    
    input {
      flex: 1;
      min-width: 300px;
      padding: 0.75rem 1rem;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 1rem;
      transition: border-color 0.2s;
    }
    
    input:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
    }
    
    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    button:hover {
      background-color: var(--secondary-color);
    }
    
    button:disabled {
      background-color: #9ca3af;
      cursor: not-allowed;
    }
    
    textarea {
      width: 100%;
      height: 500px;
      padding: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 0.875rem;
      resize: vertical;
      margin-top: 1rem;
    }
    
    .status {
      margin-top: 1rem;
      padding: 0.75rem;
      border-radius: 6px;
      display: none;
    }
    
    .error {
      background-color: #fee2e2;
      color: var(--error-color);
      display: block;
    }
    
    .success {
      background-color: #dcfce7;
      color: var(--success-color);
      display: block;
    }
    
    .progress-container {
      width: 100%;
      background-color: #e5e7eb;
      border-radius: 6px;
      margin: 1rem 0;
      display: none;
    }
    
    .progress-bar {
      height: 8px;
      background-color: var(--primary-color);
      border-radius: 6px;
      width: 0%;
      transition: width 0.3s ease;
    }
    
    .options {
      margin: 1rem 0;
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }
    
    .option-checkbox {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    footer {
      margin-top: 2rem;
      text-align: center;
      color: #6b7280;
      font-size: 0.875rem;
    }
    
    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }
      
      .input-group {
        flex-direction: column;
      }
      
      input {
        min-width: auto;
        width: 100%;
      }
      
      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <h1>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
      <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
      <line x1="12" y1="22.08" x2="12" y2="12"></line>
    </svg>
    Mini HTTrack - Webpage Copier
  </h1>
  
  <p>Download a complete copy of any webpage with all CSS inlined and images converted to base64.</p>
  
  <div class="input-group">
    <input id="urlInput" type="url" placeholder="Enter full website URL (e.g. https://example.com)" size="60">
    <button id="copyButton" onclick="copySite()">Copy Webpage</button>
  </div>
  
  <div class="options">
    <label class="option-checkbox">
      <input type="checkbox" id="inlineCSS" checked>
      Inline CSS
    </label>
    <label class="option-checkbox">
      <input type="checkbox" id="inlineImages" checked>
      Inline Images
    </label>
    <label class="option-checkbox">
      <input type="checkbox" id="minifyHTML" checked>
      Minify HTML
    </label>
  </div>
  
  <div class="progress-container" id="progressContainer">
    <div class="progress-bar" id="progressBar"></div>
  </div>
  
  <div class="status" id="statusMessage"></div>
  
  <textarea id="output" placeholder="Copied HTML will appear here..." spellcheck="false"></textarea>
  
  <footer>
    Note: Due to CORS restrictions, some resources might not be inlined properly. For complex sites, consider using a browser extension.
  </footer>

  <script>
    const proxy = "https://api.allorigins.win/raw?url=";
    let abortController = new AbortController();
    
    function showStatus(message, type = 'error') {
      const statusElement = document.getElementById('statusMessage');
      statusElement.textContent = message;
      statusElement.className = 'status ' + type;
    }
    
    function updateProgress(percentage) {
      const progressBar = document.getElementById('progressBar');
      const progressContainer = document.getElementById('progressContainer');
      
      progressBar.style.width = `${percentage}%`;
      progressContainer.style.display = percentage > 0 ? 'block' : 'none';
    }
    
    async function fetchWithTimeout(resource, options = {}) {
      const { timeout = 8000 } = options;
      
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeout);
      
      const response = await fetch(resource, {
        ...options,
        signal: controller.signal  
      });
      
      clearTimeout(id);
      return response;
    }
    
    async function inlineCSS(doc, baseUrl) {
      const links = Array.from(doc.querySelectorAll('link[rel="stylesheet"]'));
      const fetched = new Set();
      let processed = 0;
      
      updateProgress(10);
      
      for (const link of links) {
        try {
          const href = link.getAttribute('href');
          if (!href) continue;

          const cssUrl = new URL(href, baseUrl).href;
          if (fetched.has(cssUrl)) {
            link.remove();
            continue;
          }

          showStatus(`Fetching CSS: ${cssUrl}`, 'success');
          const cssText = await (await fetchWithTimeout(proxy + encodeURIComponent(cssUrl), {
            signal: abortController.signal
          })).text();
          
          const style = document.createElement('style');
          style.textContent = `/* Inlined from ${cssUrl} */\n` + cssText;
          link.replaceWith(style);
          fetched.add(cssUrl);
          
          processed++;
          updateProgress(10 + (processed / links.length * 40));
        } catch (e) {
          console.warn("Failed to inline CSS:", e);
          showStatus(`Failed to fetch CSS: ${link.href}`, 'error');
        }
      }
    }
    
    async function inlineImages(doc, baseUrl) {
      const images = Array.from(doc.querySelectorAll('img'));
      let processed = 0;
      const total = images.length;
      
      updateProgress(50);
      
      for (const img of images) {
        try {
          const src = img.getAttribute('src');
          if (!src) continue;

          const imgUrl = new URL(src, baseUrl).href;
          showStatus(`Processing image: ${imgUrl} (${processed+1}/${total})`, 'success');
          
          const response = await fetchWithTimeout(proxy + encodeURIComponent(imgUrl), {
            signal: abortController.signal
          });
          const blob = await response.blob();

          const base64 = await new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
          });

          img.src = base64;
          
          processed++;
          updateProgress(50 + (processed / total * 40));
        } catch (e) {
          console.warn("Failed to inline image:", img.src);
          showStatus(`Failed to fetch image: ${img.src}`, 'error');
        }
      }
    }
    
    function minifyHTML(html) {
      return html
        .replace(/\s+/g, ' ')
        .replace(/>\s+</g, '><')
        .trim();
    }
    
    async function copySite() {
      const urlInput = document.getElementById('urlInput').value.trim();
      const output = document.getElementById('output');
      const copyButton = document.getElementById('copyButton');
      
      if (!urlInput) {
        showStatus('Please enter a valid URL');
        return;
      }
      
      try {
        // Reset state
        abortController.abort();
        abortController = new AbortController();
        copyButton.disabled = true;
        output.value = "";
        showStatus('Starting download...', 'success');
        updateProgress(5);
        
        // Validate URL
        new URL(urlInput);
        
        const shouldInlineCSS = document.getElementById('inlineCSS').checked;
        const shouldInlineImages = document.getElementById('inlineImages').checked;
        const shouldMinify = document.getElementById('minifyHTML').checked;
        
        showStatus('Fetching HTML content...', 'success');
        const res = await fetchWithTimeout(proxy + encodeURIComponent(urlInput), {
          signal: abortController.signal
        });
        
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        
        const html = await res.text();
        
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        if (shouldInlineCSS) {
          await inlineCSS(doc, urlInput);
        } else {
          // Convert CSS links to absolute URLs
          doc.querySelectorAll('link[rel="stylesheet"]').forEach(link => {
            const href = link.getAttribute('href');
            if (href && !href.startsWith('http')) {
              link.setAttribute('href', new URL(href, urlInput).href);
            }
          });
        }
        
        if (shouldInlineImages) {
          await inlineImages(doc, urlInput);
        } else {
          // Convert image src to absolute URLs
          doc.querySelectorAll('img').forEach(img => {
            const src = img.getAttribute('src');
            if (src && !src.startsWith('http')) {
              img.setAttribute('src', new URL(src, urlInput).href);
            }
          });
        }
        
        updateProgress(95);
        showStatus('Finalizing document...', 'success');
        
        let finalHTML = "<!DOCTYPE html>\n" + doc.documentElement.outerHTML;
        
        if (shouldMinify) {
          finalHTML = minifyHTML(finalHTML);
        }
        
        output.value = finalHTML;
        updateProgress(100);
        showStatus('Webpage copied successfully!', 'success');
      } catch (err) {
        if (err.name === 'AbortError') {
          showStatus('Request was aborted', 'error');
        } else {
          output.value = '❌ Error: ' + err.message;
          showStatus('Error: ' + err.message, 'error');
          console.error(err);
        }
      } finally {
        copyButton.disabled = false;
      }
    }
    
    // Add event listener for Enter key
    document.getElementById('urlInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        copySite();
      }
    });
  </script>
</body>
</html>