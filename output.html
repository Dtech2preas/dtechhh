<!DOCTYPE html>
<html>
<head>
  <title>Mini HTTrack (Full CSS Inliner)</title>
  <style>
    body { font-family: monospace; padding: 1rem; }
    input, button { font-size: 1rem; }
    textarea { width: 100%; height: 300px; margin-top: 1rem; }
  </style>
</head>
<body>
  <h2>üï∏Ô∏è One-Page Website Copier with Full CSS Inlining</h2>
  <input id="urlInput" placeholder="Enter full site URL (e.g. https://example.com)" size="60">
  <button onclick="copySite()">Copy Homepage</button>
  <br>
  <textarea id="output" placeholder="Copied HTML will appear here..."></textarea>

  <script>
    const proxy = "https://api.allorigins.win/raw?url=";

    async function inlineCSS(doc, baseUrl) {
      const links = Array.from(doc.querySelectorAll('link[rel="stylesheet"]'));
      const fetched = new Set();

      for (const link of links) {
        try {
          const href = link.getAttribute('href');
          if (!href) continue;

          const cssUrl = new URL(href, baseUrl).href;
          if (fetched.has(cssUrl)) {
            link.remove();
            continue;
          }

          const cssText = await (await fetch(proxy + encodeURIComponent(cssUrl))).text();
          const style = document.createElement('style');
          style.textContent = `/* Inlined from ${cssUrl} */\n` + cssText;
          link.replaceWith(style);
          fetched.add(cssUrl);
        } catch (e) {
          console.warn("Failed to inline CSS:", e);
        }
      }
    }

    async function inlineImages(doc, baseUrl) {
      const images = Array.from(doc.querySelectorAll('img'));
      for (const img of images) {
        try {
          const src = img.getAttribute('src');
          if (!src) continue;

          const imgUrl = new URL(src, baseUrl).href;
          const response = await fetch(proxy + encodeURIComponent(imgUrl));
          const blob = await response.blob();

          const base64 = await new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
          });

          img.src = base64;
        } catch (e) {
          console.warn("Failed to inline image:", img.src);
        }
      }
    }

    async function copySite() {
      const url = document.getElementById('urlInput').value;
      const output = document.getElementById('output');
      output.value = "Fetching and inlining...";

      try {
        const res = await fetch(proxy + encodeURIComponent(url));
        const html = await res.text();

        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        await inlineCSS(doc, url);
        await inlineImages(doc, url);

        output.value = "<!DOCTYPE html>\n" + doc.documentElement.outerHTML;
      } catch (err) {
        output.value = '‚ùå Error: ' + err.message;
      }
    }
  </script>
</body>
</html>